//  FavoriteViewModel.swift
//  Base
//
//  Created by BaoHoang on 09/02/2023.
//  Copyright (c) baohg. All rights reserved.
//
//  This file was generated by the Educa MVVM-C Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  Template created by baohg - bao15899@gmail.com

import Foundation
import RxSwift
import RxCocoa
import UIKit

class FavoriteViewModel: BaseViewModel {
    
    struct Input {
        let getAllFavorite: Driver<Void>
        let didSelectItem: Driver<FavoriteComicItemModel>
    }
    
    struct Output {
        let favoriteComic: Driver<[FavoriteComicSection]>
        let comicSuggestIsEmpty: Driver<Bool>
    }
    
    private let bag = DisposeBag()
    private let favoriteUC: FavoriteUC
    private let coordinator: FavoriteCoordinator
    let getAllFavoriteSubject = PublishSubject<Void>()
    let deleteItemSubject = PublishSubject<IndexPath>()
    
    init(favoriteUC: FavoriteUC, coordinator: FavoriteCoordinator) {
        self.favoriteUC = favoriteUC
        self.coordinator = coordinator
    }

    func transform(input: Input) -> Output {

        let comicSuggestSubjectIsEmpty = BehaviorSubject<Bool>(value: true)
        let favoriteComicSectionRelay = BehaviorRelay<[FavoriteComicSection]>(value: [])
        var favoriteComics:[FavoriteComicItemModel] = []
        let favoriteMerge = Driver.merge(input.getAllFavorite,
                                         getAllFavoriteSubject.asDriver(onErrorJustReturn: ()))
        
        deleteItemSubject
            .asObservable()
            .subscribe(onNext: { indexPath in
                if (indexPath.row >= 0 && indexPath.row < favoriteComicSectionRelay.value.first?.items.count ?? 0) {
                    if let id = favoriteComics[indexPath.row].detailUrl {
                        favoriteComics.remove(at: indexPath.row)
                        favoriteComicSectionRelay.accept([FavoriteComicSection(items: favoriteComics)])
                        self.favoriteUC.deleteFavorite(id: id)
                    }
                }
            })
            .disposed(by: bag)
        
        favoriteMerge
            .asObservable()
            .flatMap({ _ in
                return self.favoriteUC.getAllFavorite()
                    .asDriver(onErrorJustReturn: [])
            })
            .subscribe(onNext: { data in
                let favoriteItem = data.map { comic in
                    return FavoriteComicItemModel(image: comic.image,
                                                  title: comic.title,
                                                  category: comic.category,
                                                  chapter: comic.chapter,
                                                  detailUrl: comic.detailUrl)
                }
                favoriteComics = favoriteItem
                favoriteComicSectionRelay.accept([FavoriteComicSection(items: favoriteItem)])
                comicSuggestSubjectIsEmpty.onNext(!data.isEmpty)
            })
            .disposed(by: bag)
        
        input.didSelectItem
            .asObservable()
            .subscribe(onNext: { data in
                self.coordinator.navigateToComicDetail(comicDetailUrl: data.detailUrl ?? "", title: data.title ?? "")
            })
            .disposed(by: bag)
                
        let comicSuggestIsEmptyOutput = comicSuggestSubjectIsEmpty.asDriver(onErrorJustReturn: true)
        let favoriteComicOutput = favoriteComicSectionRelay.asDriver(onErrorJustReturn: [])
        
        return Output(favoriteComic: favoriteComicOutput,
                      comicSuggestIsEmpty: comicSuggestIsEmptyOutput)
    }
}
