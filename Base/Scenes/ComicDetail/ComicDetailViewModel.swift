//  ComicDetailViewModel.swift
//  Base
//
//  Created by baohoang on 20/01/2023.
//  Copyright (c) baohg. All rights reserved.
//
//  This file was generated by the Educa MVVM-C Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  Template created by baohg - bao15899@gmail.com

import Foundation
import RxSwift
import RxCocoa

class ComicDetailViewModel: BaseViewModel {
    
    struct Input {
        let getComicDetail: Driver<Void>
        let setFavorite: Driver<Void>
        let saveComicToLocal: Driver<Void>
    }
    
    struct Output {
        let comicDetailSection: Driver<[ComicDetailSectionData]>
        let comicFavoriteStatus: Driver<Bool>
        let isLoading: Driver<Bool>
    }
    
    private let bag = DisposeBag()
    private let detailComicUrl: String
    private let comicDetailUC: ComicDetailUC
    private let coordinator: ComicDetailCoordinator
    let didSelectItem = PublishSubject<ChapterModel>()
    
    init(detailComicUrl: String, comicDetailUC: ComicDetailUC, coordinator: ComicDetailCoordinator) {
        self.detailComicUrl = detailComicUrl
        self.coordinator = coordinator
        self.comicDetailUC = comicDetailUC
    }
    
    deinit {
        print("\(self) deinit")
    }

    func transform(input: Input) -> Output {

        var listChapter: [ChapterModel] = []
        var detailComic = DetailComicModel()
        let isLoadingSubject = BehaviorSubject(value: false)
        var comicName: String = ""
        var isSelecting = false
        
        didSelectItem
            .do(onNext: { [weak self] data in
                self?.comicDetailUC.saveChapterToLocal(detailComic: detailComic, chapter: data)
                isSelecting = true
            })
            .subscribe(onNext: { [weak self] data in
                self?.coordinator.navigateToChapterDetail(chapter: data,
                                                          listChapter: listChapter,
                                                          comicName: comicName)
            })
            .disposed(by: bag)
                
        let selecteChapterMerge = Driver.merge(input.getComicDetail.mapToVoid(),
                                               didSelectItem.asDriver(onErrorJustReturn: ChapterModel()).mapToVoid())
        
        let comicDetail = selecteChapterMerge
            .do(onNext: { _ in
                isLoadingSubject.onNext(true)
            })
            .flatMap { _ -> Driver<DetailComicModel> in
                if (isSelecting) {
                    return self.comicDetailUC.getComicDetailData(url: self.detailComicUrl)
                        .asDriver(onErrorJustReturn: DetailComicModel.init())
                }
                if let cacheData = CacheManager.shared.getCache(key: "\(self.detailComicUrl)") as? DetailComicModel {
                    return Driver.just(cacheData)
                }
                return self.comicDetailUC.getComicDetailData(url: self.detailComicUrl)
                    .asDriver(onErrorJustReturn: DetailComicModel.init())
            }
            .do(onNext: { data in
                detailComic = data
                self.comicDetailUC.saveComicToLocal(detailComic: data)
                CacheManager.shared.setCache(item: data, key: "\(self.detailComicUrl)")
                listChapter = data.chapters ?? []
                comicName = data.title ?? ""
                isLoadingSubject.onNext(false)
                isSelecting = false
            })
                
        //sẽ gọi lại comicDetail để lấy data
        let comicDetailSectionOutput = comicDetail
            .flatMap { data in
                return self.comicDetailUC.getComicDetailSection(data: data)
                    .asDriver(onErrorJustReturn: [])
            }
        
        let setFavoriteOutput = input.setFavorite
            .withLatestFrom(comicDetail) { _, comic in
                return comic
            }
            .flatMap { data in
                return self.comicDetailUC.setFavorite(detailComic: data)
                    .asDriver(onErrorJustReturn: false)
        }
        
        let getFavoriteOutput = comicDetail
            .flatMap { data in
                return self.comicDetailUC.getFavorite(detailComic: data)
                    .asDriver(onErrorJustReturn: false)
            }
        
        let favoriteOutput = Driver.merge(getFavoriteOutput, setFavoriteOutput)
            .map { status in
                return status
            }
        
        let isLoadingOutput = isLoadingSubject.asDriver(onErrorJustReturn: false)
        
        return Output(comicDetailSection: comicDetailSectionOutput,
                      comicFavoriteStatus: favoriteOutput,
                      isLoading: isLoadingOutput)
    }
}
