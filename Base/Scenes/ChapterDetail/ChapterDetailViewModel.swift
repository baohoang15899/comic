//  ChapterDetailViewModel.swift
//  Base
//
//  Created by baohoang on 20/01/2023.
//  Copyright (c) baohg. All rights reserved.
//
//  This file was generated by the Educa MVVM-C Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  Template created by baohg - bao15899@gmail.com

import Foundation
import RxSwift
import RxCocoa
import UIKit

class ChapterDetailViewModel: BaseViewModel {
    
    struct Input {
        let getChapterDetail: Driver<Void>
        let getImgQualityRows: Driver<Void>
        let didSelectedItem: Driver<(row: Int, component: Int)>
        let getImgQualityDefault: Driver<Void>
    }
    
    struct Output {
        let chapterImageOutput: Driver<[ChapterImageModel]>
        let imgQualityRows: Driver<[ImageQualityModel]>
        let defaultQuality: Driver<Int>
    }
    
    private let bag = DisposeBag()
    private let chapter: ChapterModel
    private let getChapterImgSubject = BehaviorSubject<[ChapterDetailModel]>.init(value: [])
    private let dowloadImgSubject = PublishSubject<[Data]>()
    private var chapterDetail: [ChapterImageModel] = []
    private let chapterImageSubject = BehaviorSubject<[ChapterImageModel]>(value: [])
    private let chapterDetailUC: ChapterDetailUC
    var imgQuality: JPEGQuality = .medium
    
    
    init(chapter: ChapterModel, chapterDetailUC: ChapterDetailUC) {
        self.chapter = chapter
        self.chapterDetailUC = chapterDetailUC
    }
    
    deinit {
        print("\(self) deinit")
    }
    
    private func getChapterImages(data: [ChapterDetailModel]){
        let allObservables = data.map { chapterDetailUC.getChapterImage(chapter: $0) }
        
        let all = Observable.from(allObservables).merge().toArray()
        
        let sortArray = all.asObservable().map { chapters in
            return chapters.sorted {
                $0.index ?? 0 < $1.index ?? 0
            }
        }
        
        sortArray.subscribe(onNext: { chapter in
            self.chapterDetail = chapter
            self.chapterImageSubject.onNext(chapter)
        })
        .disposed(by: bag)
    }
    
    func calulateImgHeight(index: Int, screenRatio: CGFloat, frameWidth: CGFloat) -> CGFloat {
        var ratio = 0.0
        if (index > 0 && index < chapterDetail.count) {
            let currentImage = chapterDetail[index].image
            if let imgHeight = currentImage?.size.height, let imgWidth = currentImage?.size.width {
//                print("current height: \(imgHeight), frame width \(frameWidth), current width: \(imgWidth), width ratio: \(frameWidth/imgWidth)")
                ratio = imgHeight * (frameWidth / imgWidth)
            }
        }
        return ratio
    }
    
    func transform(input: Input) -> Output {
        
        let startGetChapterDetail = Driver.merge(input.getChapterDetail, input.didSelectedItem.mapToVoid())
        
        startGetChapterDetail
            .asObservable()
            .flatMapLatest { _ in
                return self.chapterDetailUC.getChapterDetail(url: self.chapter.chapterUrl ?? "")
            }
            .subscribe(onNext: { data in
                self.getChapterImages(data: data)
            })
            .disposed(by: bag)
        
        let imgQualityRowsOutput = input.getImgQualityRows
            .map { _ -> [ImageQualityModel] in
                let data: [ImageQualityModel] = [
                    ImageQualityModel(title: L10n.ComicDetail.Quality.lowest, quality: .lowest),
                    ImageQualityModel(title: L10n.ComicDetail.Quality.low, quality: .low),
                    ImageQualityModel(title: L10n.ComicDetail.Quality.medium, quality: .medium),
                    ImageQualityModel(title: L10n.ComicDetail.Quality.high, quality: .high),
                    ImageQualityModel(title: L10n.ComicDetail.Quality.highest, quality: .highest),
                ]
                return data
            }
        
       let defaultQualityOutput = input.getImgQualityDefault
            .flatMap({ _ in
                return imgQualityRowsOutput
            })
            .map({ data -> Int in
                return data.firstIndex { $0.quality == self.imgQuality } ?? 0
            })
        
        input.didSelectedItem
            .asObservable()
            .withLatestFrom(imgQualityRowsOutput) { pickerData, imgQuality in
                return imgQuality[pickerData.row]
            }
            .subscribe(onNext: { data in
                self.imgQuality = data.quality ?? .medium
            })
            .disposed(by: bag)

        let chapterImageOutput = chapterImageSubject.asDriver(onErrorJustReturn: [])
        
        return Output(chapterImageOutput: chapterImageOutput,
                      imgQualityRows: imgQualityRowsOutput,
                      defaultQuality: defaultQualityOutput)
    }
}
