//  ChapterDetailViewModel.swift
//  Base
//
//  Created by baohoang on 20/01/2023.
//  Copyright (c) baohg. All rights reserved.
//
//  This file was generated by the Educa MVVM-C Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  Template created by baohg - bao15899@gmail.com

import Foundation
import RxSwift
import RxCocoa
import UIKit

class ChapterDetailViewModel: BaseViewModel {
    
    struct Input {
        let getChapterDetail: Driver<Void>
        let getChapterRows: Driver<Void>
        let didSelectedItem: Driver<(row: Int, component: Int)>
        let willDisplayCell: Driver<(cell: UITableViewCell, indexPath: IndexPath )>
        let getCurrentChapter: Driver<Void>
        let nextChapter: Driver<Void>
        let previousChapter: Driver<Void>
        let submitChangeChapter: Driver<Void>
        let goBack: Driver<Void>
        let pullToRefresh: Driver<Void>
    }
    
    struct Output {
        let chapterImageOutput: Driver<[ChapterImageModel]>
        let isShowConfigView: Driver<Bool>
        let comicTitle: Driver<String>
        let allChapter: Driver<[ChapterModel]>
        let chapterTitle: Driver<String>
        let currentChapterIndex: Driver<Int>
        let isLoading: Driver<Bool>
        let changingChapter: Driver<Void>
        let canNextChap: Driver<Bool>
        let canBackChap: Driver<Bool>
        let isRefresing: Driver<Bool>
        let isLoadingScreen: Driver<Bool>
    }
    
    private let bag = DisposeBag()
    private var chapter: ChapterModel
    private let listChapter: [ChapterModel]
    private let getChapterImgSubject = BehaviorSubject<[ChapterDetailModel]>.init(value: [])
    private let dowloadImgSubject = PublishSubject<[Data]>()
    private var chapterDetail: [ChapterImageModel] = []
    private let chapterImageSubject = BehaviorSubject<[ChapterImageModel]>(value: [])
    private let chapterDetailUC: ChapterDetailUC
    private let coordinator: ComicDetailCoordinator
    private let comicName: String
    private let loadingRelay = BehaviorRelay(value: true)
    private let currentIndex = BehaviorRelay(value: 0)
    private let canNextChapSubject = BehaviorSubject(value: true)
    private let canBackChapSubject = BehaviorSubject(value: true)
    let viewOnTapSubject = PublishSubject<Void>()
    var imgQuality: JPEGQuality = .high
    
    
    init(chapter: ChapterModel, chapterDetailUC: ChapterDetailUC, coordinator: ComicDetailCoordinator, listChapter: [ChapterModel], comicName: String) {
        self.chapter = chapter
        self.listChapter = listChapter
        self.coordinator = coordinator
        self.chapterDetailUC = chapterDetailUC
        self.comicName = comicName
    }
    
    deinit {
        print("\(self) deinit")
    }
    
    private func getChapterImages(data: [ChapterDetailModel]){
        if let cacheData = CacheManager.shared.getCache(key: "\(CacheKey.chapter)\(self.chapter.chapterUrl ?? "")") as? [ChapterImageModel] {
            self.chapterDetail = cacheData
            self.chapterImageSubject.onNext(cacheData)
            self.loadingRelay.accept(false)
            self.canNextChapSubject.onNext((self.currentIndex.value < self.listChapter.count - 1 && !self.loadingRelay.value))
            self.canBackChapSubject.onNext((self.currentIndex.value > 0 && !self.loadingRelay.value))
        } else {
            let allObservables = data.map { chapterDetailUC.getChapterImage(chapter: $0) }
            
            let all = Observable.from(allObservables).merge().toArray()
            
            let sortArray = all.asObservable().map { chapters in
                return chapters.sorted {
                    $0.index ?? 0 < $1.index ?? 0
                }
            }
            
            sortArray.subscribe(onNext: { chapters in
                CacheManager.shared.setCache(item: NSArray(array: chapters), key: "\(CacheKey.chapter)\(self.chapter.chapterUrl ?? "")")
                self.chapterDetail = chapters
                self.chapterImageSubject.onNext(chapters)
                self.loadingRelay.accept(false)
                self.canNextChapSubject.onNext((self.currentIndex.value < self.listChapter.count - 1 && !self.loadingRelay.value))
                self.canBackChapSubject.onNext((self.currentIndex.value > 0 && !self.loadingRelay.value))
            })
            .disposed(by: bag)
        }
    }
    
    func calulateImgHeight(index: Int, screenRatio: CGFloat, frameWidth: CGFloat) -> CGFloat {
        var ratio = 0.0
        if (index > 0 && index < chapterDetail.count) {
            let currentImage = chapterDetail[index].image
            if let imgHeight = currentImage?.size.height, let imgWidth = currentImage?.size.width {
                //                print("current height: \(imgHeight), frame width \(frameWidth), current width: \(imgWidth), width ratio: \(frameWidth/imgWidth)")
                ratio = imgHeight * (frameWidth / imgWidth)
            }
        }
        return ratio
    }
    
    func transform(input: Input) -> Output {
        
        let isLoadingSubject = BehaviorSubject(value: false)
        let currentChapterTitleSubject = BehaviorSubject(value: "")
        let submitChangeChapterSubject = PublishSubject<Void>()
        let isShowConfigViewRelay = BehaviorRelay(value: false)
        let isRefreshRelay = BehaviorRelay(value: false)
        let startGetChapterDetail = Driver.merge(input.getChapterDetail,
                                                 input.nextChapter,
                                                 input.previousChapter,
                                                 input.submitChangeChapter,
                                                 input.pullToRefresh)
        let changeChapterMerge = Driver.merge(input.nextChapter, input.previousChapter, input.getCurrentChapter)
        
        input.pullToRefresh
            .asObservable()
            .subscribe(onNext: { value in
                self.chapterDetail = []
                self.chapterImageSubject.onNext([])
                isRefreshRelay.accept(true)
            })
            .disposed(by: bag)
        
        input.nextChapter
            .asObservable()
            .subscribe(onNext: { _ in
                if (self.currentIndex.value >= 0 && self.currentIndex.value < self.listChapter.count - 1 && !self.loadingRelay.value) {
                    self.chapterDetail = []
                    self.chapterImageSubject.onNext([])
                    self.currentIndex.accept(self.currentIndex.value + 1)
                    self.chapter = self.listChapter[self.currentIndex.value]
                }
            })
            .disposed(by: bag)
        
        input.previousChapter
            .asObservable()
            .subscribe(onNext: { _ in
                if (self.currentIndex.value > 0 && !self.loadingRelay.value) {
                    self.chapterDetail = []
                    self.chapterImageSubject.onNext([])
                    self.currentIndex.accept(self.currentIndex.value - 1)
                    self.chapter = self.listChapter[self.currentIndex.value]
                }
            })
            .disposed(by: bag)
        
        let selectedChapter = input.didSelectedItem
            .map { (row, component) -> ChapterModel in
                return self.listChapter[row]
            }
        
        input.submitChangeChapter
            .asObservable()
            .withLatestFrom(selectedChapter) { _, chapter in
                return chapter
            }
            .subscribe(onNext: { chapter in
                submitChangeChapterSubject.onNext(())
                self.chapterDetail = []
                self.chapterImageSubject.onNext([])
                self.chapter = chapter
            })
            .disposed(by: bag)
        
        input.willDisplayCell
            .asObservable()
            .subscribe(onNext: { cell in
                let lastRow = self.chapterDetail.count - 1
                if(cell.indexPath.row == lastRow) {
                    isShowConfigViewRelay.accept(true)
                }
            })
            .disposed(by: bag)
        
        startGetChapterDetail
            .asObservable()
            .do(onNext: { _ in
                if (!isRefreshRelay.value) {
                    isLoadingSubject.onNext(true)
                }
                self.loadingRelay.accept(true)
                self.canNextChapSubject.onNext(false)
                self.canBackChapSubject.onNext(false)
                self.currentIndex.accept(self.listChapter.firstIndex(of: self.chapter) ?? 0)
                currentChapterTitleSubject.onNext(self.chapter.title ?? "")
            })
                .flatMap { _ -> Observable<[ChapterDetailModel]> in
                    if isRefreshRelay.value {
                        return self.chapterDetailUC.getChapterDetail(url: self.chapter.chapterUrl ?? "")
                    } else {
                        if let _ = CacheManager.shared.getCache(key: "\(CacheKey.chapter)\(self.chapter.chapterUrl ?? "")") {
                            return Observable.just([])
                        } else {
                            return self.chapterDetailUC.getChapterDetail(url: self.chapter.chapterUrl ?? "")
                        }
                    }
                }
                .subscribe(onNext: { data in
                    self.getChapterImages(data: data)
                    isRefreshRelay.accept(false)
                    isLoadingSubject.onNext(false)
                })
                .disposed(by: bag)
        
        let chapterRowsOutput = input.getChapterRows
            .map { _ -> [ChapterModel] in
                return self.listChapter
            }
        
        let currentChapterIndexOutput = changeChapterMerge
            .map({ _ -> Int in
                return self.currentIndex.value
            })
        
        viewOnTapSubject
            .subscribe(onNext: {
                isShowConfigViewRelay.accept(!isShowConfigViewRelay.value)
            })
            .disposed(by: bag)
        
        let comicNameOutput = Observable.just(self.comicName).asDriver(onErrorJustReturn: "")
        
        let chapterTitleOutput = currentChapterTitleSubject.asDriver(onErrorJustReturn: "")
        
        input.goBack
            .asObservable()
            .subscribe(onNext: {
                self.coordinator.goBack()
            })
            .disposed(by: bag)
        
        let chapterImageOutput = chapterImageSubject.asDriver(onErrorJustReturn: [])
        let loadingOutput = loadingRelay.asDriver(onErrorJustReturn: false)
        let changingChapterOutput = submitChangeChapterSubject.asDriver(onErrorJustReturn: ())
        let canNextChapOutput = canNextChapSubject.asDriver(onErrorJustReturn: false)
        let canBackChapOutput = canBackChapSubject.asDriver(onErrorJustReturn: false)
        let isShowConfigViewOutput = isShowConfigViewRelay.asDriver(onErrorJustReturn: false)
        let isLoadingOutput = isLoadingSubject.asDriver(onErrorJustReturn: false)
                        
        return Output(chapterImageOutput: chapterImageOutput,
                      isShowConfigView: isShowConfigViewOutput,
                      comicTitle: comicNameOutput,
                      allChapter: chapterRowsOutput,
                      chapterTitle: chapterTitleOutput,
                      currentChapterIndex: currentChapterIndexOutput,
                      isLoading: loadingOutput,
                      changingChapter: changingChapterOutput,
                      canNextChap: canNextChapOutput,
                      canBackChap: canBackChapOutput,
                      isRefresing: isRefreshRelay.asDriver(onErrorJustReturn: false),
                      isLoadingScreen: isLoadingOutput)
    }
}
